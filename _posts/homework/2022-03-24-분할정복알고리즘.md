---
layout: post
date: 2022-03-24 17:11:31 +0900
title: "분할 정복 알고리즘"
---

>>분할 정복 알고리즘 (Divide-and-Conquer)

**분할 정복 알고리즘이란 주어진 문제의 입력을 분할하여 문제를 해결(정복)하는 방식의 알고리즘이다.**

주어진 문제를 분할함 -> 분할한 문제의 해를 얻음 -> 분할한 문제의 해를 취합해 원래 문제의 해를 얻음

*알아볼 분할 정복 알고리즘의 분류*

1. 합병 정렬
2. 퀵 정렬
3. 선택 문제
4. 최근접 점의 쌍 찾기

>>합병 정렬

**합병정렬은 입력이 2개의 부분문제로 분할되고, 부분문제의 크기가 1/2로 감소하는 분할 정복의 알고리즘이다.**

합병정렬 알고리즘
```
MergeSort(A,p,q)
입력: A[p]~A[q]
출력: 정렬된 A[p]~A[q]
if(p < q) {                               // Line1. 배열의 원소의 수가 2개 이상이면 
    k = [(p+q)/2]                         // Line2. k=반으로 나누기 위한 중간 원소의 인덱스
    MergeSort(A,p,k)                      // Line3. 앞부분 재귀 호출
    MergeSort(A,k+1,q)                    // Line4. 뒷부분 재귀 호출
    A[p]~A[k]와 A[k+1]~A[q]를 합병한다.    // Line5
}
```

· **Line1**은 원소가 2개 이상일 때만 다음단계가 수행되게 한다.

· **Line2**은 정렬할 부분의 원소를 1/2로 나눈다.

· **Line3~4**은 재귀호출하여 각각 정렬한다.

· **Line5**은 각각 정렬된 부분을 합병한다.

![](https://search.pstatic.net/common/?src=http%3A%2F%2Fblogfiles.naver.net%2FMjAyMjAxMTRfMTc0%2FMDAxNjQyMTY0Njc1Mjk3.ab4kTr-nMb3ZSvEuj4AzT8Rp7UEQ7UQGhDA7w2uCQJcg.1YniBoo1j4MIDXwRCFZjJS4E0sm8mAb8af5Wp-VJxYog.PNG.julie0427%2Fimage.png&type=sc960_832)

까만선은 분할이고 빨간선은 합병이다.

**합병 정렬의 시간 복잡도**

위 그림에서 분할하는 부분은 배열의 중간 인덱스 계산과 2번의 재귀 호출을 하는 것이므로 **O(1)** 시간이 걸린다.

반면에 합병을 하는 수행시간은 입력의 크기에 비례한다. A와 B의 크기가 각각 n과 m이라면 최대 비교 횟수는 (n+m-1)이다.

∴합병의 시간복잡도는 **O(n+m)**이다.

합병 정렬에서 수행되는 총 비교 횟수는 쉬운 계산 방법 중에 층별로 살펴보는 것이 있다.

각 층을 보면 모든 숫자가 합병에 참여 하는데 합병은 합병되는 입력 크기에 비례하므로 각 층에서 수행된 비교 횟수는 O(n)이다.

만약 n=8 이라고 가정할 때 층수는 8개의 숫자를 반으로, 반의 반으로, 반의 반의 반으로 나누면 3층이 된다.

결국 n을 계속하여 1/2로 나누다가 더이상 나눌 수 없는 1이 될때 분할을 중단하는 것으로 보아 층수 k는 n=2^k 로 표현되고 k=log n(밑이 2임)임을 알수 있다

결과적으로 합병 정렬의 시간복잡도는 **(층수) X O(n) = log n X O(n) = O(nlogn)이다.**

>>퀵 정렬(Quick Sort)

**퀵 정렬은 분할 정복 알고리즘으로 분류되나, 사실 알고리즘이 수행되는 과정을 살펴보면 정복 후 분할하는 알고리즘이다. 퀵 정렬 알고리즘은 문제를 2개의 부분문제로 분할하는데, 각 부분문제의 크기가 일정하지 않은 형태의 분할 정복 알고리즘이다.**

퀵 정렬은 피봇이라 일컫는 원소를 기준으로 피봇보다 작으면 왼쪽, 크면 오른쪽에 위치하도록 분할하고 분할된 부분정렬들에 대해서도 동일한 과정을 재귀적으로 수행한다.

퀵 정렬 알고리즘

```
QuickSort(A, left, right)
입력: 배열 A[left]~A[right]
출력: 정렬된 배열 A[left]~A[right]
if(left < right){  //Line1
    피봇을 A[left]~A[right] 중에서 선택하고, 피봇을 A[left]와 자리를 바꾼 후, 
    피봇과 배열의 각 원소를 비교하여 피봇보다 작은 숫자들은 A[left]~A[p-1]로 옮기고, 
    피봇보다 큰 숫자들은  A[p+1]~A[right]로 옮기며, 피봇은 A[p]에 놓는다. //Line2
    QuickSort(A, left, p-1)  //Line3. 피봇보다 작은 그룹
    QuickSort(A, p+1, right) //Line4. 피봇보다 큰 그룹
}
```

· **Line1** 에서 배열A의 가장 왼쪽 원소의 인덱스가 가장 오른쪽 원소의 인덱스보다 작으면 Line 2~4에서 정렬을 수행한다.

· **Line2** 에서 피봇을 선택하고 원소들과 피봇을 각각 비교하여 알맞은 위치에 위치시킨다.

· **Line3** 에서 피봇보다 작은 그룹을 재귀적으로 호출한다.

· **Line4** 에서 피봇보다 큰 그룹을 재귀적으로 호출한다.

**피봇 선정 방법**

1. 랜덤하게 선정하는 방법

2. 3 숫자의 중앙값으로 선정하는 방법 :가장 왼쪽, 중간, 가장 오른쪽 숫자중에 중앙값을 피봇으로 정한다.

**퀵 정렬의 시간복잡도**

1. 퀵 정렬의 최악 시간 복잡도

    입력의 크기가 n이라면, (n-1) + (n-2) + (n-3) + ··· + 2 + 1 = n(n-1)/2 = O(n^2)이다.

2. 퀵 정렬의 최선 시간 복잡도
    
    입력의 중앙값이 피봇이 되어서 항상 1/2씩 분할한다면 각 층에서 각각의 원소가 피봇과 1회 비교되기 때문에 비교 횟수는 O(n)이다.

    그러므로 총 비교 횟수는 O(n) X 층수 = O(n) X (log n)이다.(log 밑이 2임) 그러므로 퀵 정렬의 최선 경우 시간복잡도는 O(nlogn)이다.

>>선택 문제(Selection)

**선택 문제는 n개의 숫자들 중에서 k번째로 작은 숫자를 찾는 문제이다.**

선택 문제는 숫자 찾기 문제이다. 따라서 임의의 숫자를 효율적으로 찾는 이진탐색에서 아이디어를 찾는다. 이진탐색은 정렬된 입력의 중간에 있는 숫자와 찾고자 하는 숫자를 비교함으로써, 입력을 1/2로 나눈 두 부분 중에서 한 부분만을 검색한다. 하지만 선택 문제는 입력이 정렬되어 있지 않으므로 입력 숫자들 중에서 피봇을 선택하여 분할한다. Small group은 피봇보다 작은 숫자 그룹 Large group은 피봇보다 큰 숫자 그룹일 때 각 그룹의 크기를 알면 k번째 작은 숫자가 어느 그룹에 있는지 알 수 있다.

선택 문제 알고리즘
```
Selection(A, left, right, k)
입력: A[left]~A[right]와 k, 단, 1<=k<=|A|,|A|=right-left+1
출력: A[left]~A[right]에서 k번째 작은 원소
피봇을 A[left]~A[right]에서 랜덤하게 선택하고, 피봇과 A[left]의 자리를 바꾼 후, 
피봇과 배열의 각 원소를 비교하여 피봇보다 작은 숫자는 A[left]~A[p-1]로 옮기고, 
피봇보다 큰 숫자는 A[p+1]~A[right]로 옮기며, 피봇은 A[p]에 놓는다  //Line1
S = (p - 1) - left + 1                  // Line2. S = Small group의 크기
if (k <= S) Selection(A, left, p-1, k)  // Line3. Small group에서 찾기
else if (k = S + 1) return A[p]         // Line4. 피봇 = k번째 작은 숫자
else Selection(A, p+1 right, k-S-1)     // Line5. large group에서 찾기
```

· **Line2** 에서는 입력을 두 그룹으로 분할 후, A[p]가 피봇이 있는 곳이기 때문에 Small group의 크기를 알 수 있다. 즉 Small group의 가장 오른쪽 원소의 인덱스가 (p-1)이므로, Small group의 크기 S는 (p-1)-left+1이다.

· **Line3** 에서 k번째 작은 수가 Small group이므로 Selection(A, left, p-1, k)을 호출한다.

· **Line4** 에서 k번째 작은 수가 피봇이므로 해를 찾은 것이다.

· **Line5** 에서 k번째 작은 수가 Large group에 속하므로 Selection(A, p+1, right, k-S-1)을 호출한다. 이때 (k-S-1)번째 작은 수를 Large group에서 찾아야 한다. 왜냐하면 피봇이 k번째 작은 수보다 작고, S는 Small group의 크기이기 때문이다.

**good분할과 bad분할**

피봇이 입력을 Small group과 Large group으로 분할하고, 두 그룹 중의 하나의 크기가 3/4과 같거나 그보다 크면 bad분할이라고 정의하고 good 분할은 그 반대이다. 피봇을 랜덤하게 정하면 good분할이 될 확률은 1/2이다.

**선택 분할의 시간복잡도**

처음 입력의 크기가 n일 때 피봇을 랜덤하게 정한 후 두 그룹으로 분할. 이 과정에 소요되는 시간은 O(n)이다. 분할 후 good분할만 일어난다고 가정했을 때 큰 부분의 최대 크기는 ((3/4* n)-1)이다. 즉 입력의 크기가 n에서부터 3/4배로 연속적으로 감소되고, 입력 크기가 1일때는 더 이상 분할이 안된다. 따라서 선택분할의 시간 복잡도는 O[n + 3/4* n + (3/4)^2* n + (3/4)^3* n + ··· + (3/4)^i* n] = O(n) 그러므로 선택 분할 평균 경우 시간 복잡도는 2 X O(n) = O(n)이다. 2를 곱한 이유는 평균 2번만에 good 분할이 되기 때문이다.

>>최근접 점의 쌍 찾기(Closest Pair)

**최근접 점의 쌍을 찾는 문제는 2차원 평면상의 n개의 점이 입력으로 주어질 때, 거리가 가장 가까운 한 쌍의 점을 찾는 문제이다.**

최근접 점의 쌍을 찾는 분할 정복 알고리즘

```
입력: x-좌표의 오름차순으로 정렬된 배열 S에는 i개의 점(단, 각 점은(x,y)로 표현된다.)이 주어진다.
출력: S에 있는 점들 중 최근접 점의 쌍의 거리
if(i <= 3) return(2 또는 3개의 점들 사이의 최근접 쌍)  //Line1
정렬된 S를 같은 크기의 S(Left)과 S(Right)로 분할한다. 단 |S|가 홀수이면, |S(L)| = |S(R)| + 1이 되도록 분할한다.  //Line2
CP(L) = ClosetPair(S(L))  //Line3. CP(L)은 S(L)에서의 최근접 점의 쌍이다.
CP(R) = ClosetPair(S(R))  //Line4. CP(R)은 S(R)에서의 최근접 점의 쌍이다.
d = min{dist(CP(L)), dist(CP(R))}일 때, 중간 영역에 속하는 점들 중에서 최근접 점의 쌍을 찾아서 이를 CP(C)라고 하자. 단 dist()는 두 점 사이의 거리이다.
return(CP(L), CP(C), CP(R) 중에서 거리가 가장 짧은 쌍)
```

· Line1 에서는 S에 있는 점의 수가 3개 이하이면 더 이상 분할하지 않는다.

· Line2 에서는 x-좌표로 정렬된 S를 왼쪽과 오른쪽에 같은 개수의 점을 가지는 S(L), S(R)로 분할한다. 만일 점의 수가 홀수면 S(L)에 1개 많게 분할한다.

· Line3~4 에서는 분할된 S(L)과 S(R)에 대해서 재귀적으로 최근접 점의 쌍을 찾아서 각각 CP(L), CP(R)이라고 놓는다.

· Line5 에서는 CP(L)간의 거리인 dist(CP(L))과 CP(R)간의 거리인 dist(CP(R)) 중에서, 짧은 거리를 d라고 놓는다. 그리고 d를 이용하여 중간 영역에 속하는 점들을 찾고, 이 점들 중에서 최근접 점의 쌍을 찾아서 이를 CP(C)라고 놓는다.

· Line6 에서는 CP(L), CP(R), CP(C) 중에서 가장 짧은 거리를 가진 쌍을 해로서 리턴한다.

**ClosestPair 알고리즘의 시간 복잡도**

ClosestPair 알고리즘의 분할 과정은 합병 정렬의 분할 과정과 동일하다. 그러나 ClosestPair 알고리즘에서는 해를 취합하여 올라가는 과정에서 
O(nlogn) 시간이 걸린다. 여기에 층수인 logn 을 곱하면 ClosestPair의 시간 복잡도는 O(nlog²n)이 된다.

>>분할 정복을 적용하는 데 있어서 주의할 점

1. 분할 정복이 부적절한 경우는 입력이 분할될 때마다 분할된 부분문제의 입력 크기의 합이 분할되기 전의 입력 크기보다 매우 커지는 경우이다.

    ex) n번째의 피보나치 수를 구하는 데 F(n) = F(n-1) + F(n-2)로 정의되므로 재귀 호출을 사용하는 것이 자연스러워 보이나, 이 경우 입력은 1개이지만, 사실상 n의 값 자체가 입력 크기인 것이다. 따라서 n이라는 숫자로 인해 2개의 부분문제인 F(n-1)과 F(n-2)가 만들어지고 2개의 입력 크기의 합이 (n-1) + (n-2) = 2n-3 이 되어서, 분할 후 입력 크기가 거의 2배로 늘어난다. 이러한 경우 분할 정복 알고리즘을 사용하는 것은 매우 부적절하며 다른 방법을 찾아야 하는데 그 방법은 for-루프를 사용하는 것이다
    
    ```
    FibNumber(n)
    F[0]=0
    F[1]=1
    for i=2 to n
        F[i] = F[i-1] + F[I-2]
    ```

    이 경우 F(n)을 중복된 계산 없이 구할 수 있고, 이 알고리즘의 시간복잡도는 루프의 수행 횟수로서 O(n)인 것을 쉽게 알 수 있다.

2. 취합(정복)과정
